{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"cloudflare-operator Documentation \u00b6 The goal of cloudflare-operator is to manage Cloudflare DNS records using Kubernetes objects. cloudflare-operator is built from the ground up to use Kubernetes' API extension system. Who is cloudflare-operator for? \u00b6 cloudflare-operator helps to: Manage Cloudflare DNS records using Kubernetes objects Keep Cloudflare DNS records up to date Update your external IP address on Cloudflare DNS records What can I do with cloudflare-operator? \u00b6 cloudflare-operator is based on a set of Kubernetes API extensions (\"custom resources\"), which control Cloudflare DNS records. Where do I start? \u00b6 Following this guide will just take a couple of minutes to complete. After installing the cloudflare-operator helm chart and adding some annotation to your ingresses, cloudflare-operator will take care of your Cloudflare DNS records. More detail on what\u2019s in cloudflare-operator \u00b6 Features: Add, update and delete Cloudflare DNS records Update Cloudflare DNS records if your external IP address changes","title":"Home"},{"location":"#cloudflare-operator-documentation","text":"The goal of cloudflare-operator is to manage Cloudflare DNS records using Kubernetes objects. cloudflare-operator is built from the ground up to use Kubernetes' API extension system.","title":"cloudflare-operator Documentation"},{"location":"#who-is-cloudflare-operator-for","text":"cloudflare-operator helps to: Manage Cloudflare DNS records using Kubernetes objects Keep Cloudflare DNS records up to date Update your external IP address on Cloudflare DNS records","title":"Who is cloudflare-operator for?"},{"location":"#what-can-i-do-with-cloudflare-operator","text":"cloudflare-operator is based on a set of Kubernetes API extensions (\"custom resources\"), which control Cloudflare DNS records.","title":"What can I do with cloudflare-operator?"},{"location":"#where-do-i-start","text":"Following this guide will just take a couple of minutes to complete. After installing the cloudflare-operator helm chart and adding some annotation to your ingresses, cloudflare-operator will take care of your Cloudflare DNS records.","title":"Where do I start?"},{"location":"#more-detail-on-whats-in-cloudflare-operator","text":"Features: Add, update and delete Cloudflare DNS records Update Cloudflare DNS records if your external IP address changes","title":"More detail on what\u2019s in cloudflare-operator"},{"location":"api_reference/","text":"API Reference \u00b6 Check out the auto-generated CRD reference over at doc.crds.dev","title":"API Reference"},{"location":"api_reference/#api-reference","text":"Check out the auto-generated CRD reference over at doc.crds.dev","title":"API Reference"},{"location":"core_concept/","text":"Core Concept \u00b6 The goal of cloudflare-operator is to manage Cloudflare DNS records using Kubernetes objects. Architecture \u00b6 Preamble Cloudflare DNS Record \u00b6 A Cloudflare DNS record has the following fields: Type \u00b6 Cloudflare can handle multiple types. At the moment cloudflare-operator only supports A and CNAME records. A An A record must point to a valid IPv4 address (e.g. 172.4.20.69 ). cloudflare-operator use case Let cloudflare-operator create an A record for your root domain (e.g. example.com ). CNAME A CNAME record must point to a valid domain (e.g. example.com ). Cloudflare has the ability to point a CNAME record to an A record. Proxy Status and TTL of the CNAME record will be passed to the A record. cloudflare-operator use case Let cloudflare-operator create CNAME records for all your subdomains that point to your A record root domain. This is not mandatory but recommended, since cloudflare-operator only has to change one DNS record if your external IPv4 address changes. Name \u00b6 Must be a valid domain or subdomain (e.g. example.com or blog.example.com ). Content \u00b6 If type is A , the content must be a valid IPv4 address. If type is CNAME , the content must be a valid domain. cloudflare-operator use case Our recommendation is to point all your subdomains to your root domain (e.g. example.com ). Proxy Status \u00b6 Since Cloudflare is not only a DNS provider, it also has the ability to proxy requests through its CDN. This feature also enables WAF (web application firewall) protection. The proxied field is used to enable or disable this feature. TTL \u00b6 TTL (time to live) is a setting that tells the DNS resolver how long to cache a query before requesting a new one. Example \u00b6 Type Name Content Proxy Status TTL A example.com 178.4.20.69 true Auto CNAME www example.com true Auto A blog 142.251.36.35 true Auto CNAME vpn example.com false 120 www.example.com is hosted on your server at home with your external IPv4 address 178.4.20.69 . blog.example.com is hosted on a cloud provider instance with the IPv4 address 142.251.36.35 Account \u00b6 The Account object contains your Cloudflare credentials (email & global API key) and owns Zone objects. Example: --- apiVersion : cf.containeroo.ch/v1beta1 kind : Account metadata : name : account-sample spec : email : mail@example.com globalAPIKey : secretRef : name : global-api-key namespace : default # managedZones: # - example.com # - other.com If cloudflare-operator should only manage some zones, you can specify them in the managedZones field. Self-Healing \u00b6 The Account controller reconciles itself at the given interval if an error occurs. See the following table: Error Interval referenced secret ( secretRef ) not found 30s apiKey in referenced secret ( secretRef ) not found 30s connection to Cloudflare 30s fetching zones from Cloudflare 30s fetching zones from Zone object 30s Zone \u00b6 The Zone object stores the zone id. This object will be automatically created by cloudflare-operator based on the zones available in the Cloudflare account. If a zone is not in the Account.spec.managedZones field, it will not be managed by cloudflare-operator. cloudflare-operator checks if a given DNSRecord.spec.name ends with Zone.spec.name to evaluate in which Cloudflare zone the dns record should be created. cloudflare-operator will fetch in the given interval ( spec.interval ) all Cloudflare DNS records for each Zone object and deletes them on Cloudflare if they are not present in Kubernetes. The interval will be inherited from Account.spec.interval . Example: --- apiVersion : cf.containeroo.ch/v1beta1 kind : Zone metadata : name : example-com spec : id : abcdef123456 name : example.com Self-Healing \u00b6 The Zone controller reconcile itself at the given interval if an error occurs. See following table: Error Interval apiKey in secret from Account.secretRef is empty 5s fetching zones from Cloudflare 30s fetching DNSRecord objects 30s fetching DNS records from Cloudflare 30s IP \u00b6 The IP object has two purposes: DRY (Don't Repeat Yourself) Let's say you have multiple DNSRecords pointing to the same IP. You can use the IP object to avoid repeating the IP address in the DNSRecord.spec.content field. If you change the IP object, cloudflare-operator will automatically update the DNSRecord.spec.content fields. Dynamic DNS If type is set to dynamic , cloudflare-operator will fetch your IPv4 address at the specified interval ( spec.interval ). Type Static \u00b6 An IP object with type static will update Cloudflare DNS records at the given interval ( DNSRecord.spec.interval ) with its address . Example: --- apiVersion : cf.containeroo.ch/v1beta1 kind : IP metadata : name : static-address spec : type : static address : 142.251.36.35 Type Dynamic \u00b6 An IP object with type dynamic will fetch an IPv4 address from the defined .spec.ipSources[*].url at the given interval ( .spec.interval ). If more than one ipSources are configured, cloudflare-operator shuffles the list with ipSources and tries to fetch a valid IPv4 address, until the response is valid. If none of the ipSources returns a valid IPv4 address, cloudflare-operator will set the status of the IP object to failed . Default interval is set to 5 minutes. An ipSource can have the following keys: Key Description Example url URL to fetch IPv4 address https://ipecho.net requestBody Additional request body to send to the url requestHeaders Additional request headers to send to the url . The key will be passed as http header and the value will be passed as headers value Accept: application/json requestHeadersSecretRef Link to a secret with additional http headers. All secret keys will be passed as http header and the corresponding secret values will be passed as headers value See example below requestMethod HTTP request method. Possible values are GET , POST , PUT or DELETE GET responseRegex If the IPv4 address must be extracted from the http response. Uses the default golang regex engine. \\d{1,3}\\.\\d{1,3}.\\.\\d{1,3}\\.\\d{1,3} responseJSONPath JSONPath to extract IPv4 address. Uses the kubectl jsonpath library. '{.ip}' responseRegex Be aware that the http request will fetch the complete html document and not what you see in your browser! Note If neither responseJSONPath nor responseRegex is set, cloudflare-operator will try to parse the complete html document as an IPv4 address. Examples: Fetch your external IPv4 address from three \"IP\" providers --- apiVersion : cf.containeroo.ch/v1beta1 kind : IP metadata : name : external-ipv4 spec : type : dynamic ipSources : - url : https://ipecho.net responseRegex : \\d{1,3}\\.\\d{1,3}.\\.\\d{1,3}\\.\\d{1,3} - url : https://api.ipify.org?format=json responseJSONPath : '{.ip}' - url : https://checkip.amazonaws.com interval : 5m Info Because more than one ipSource is set, cloudflare-operator shuffles the list with ipSources and tries to fetch a valid IPv4 address, until the response is valid. If none of the ipSources returns a valid IPv4 address, cloudflare-operator will set the status of the IP object to failed . Fetch your external IPv4 from a cloud provider Create a secret with your provider API credentials: --- apiVersion : v1 kind : Secret metadata : name : hetzner-bearer-token namespace : default type : Opaque stringData : Authorization : Bearer TOKEN123 Create an IP object which references the secret created above. --- apiVersion : cf.containeroo.ch/v1beta1 kind : IP metadata : name : hetzner-ipv4 spec : type : dynamic ipSources : - url : https://api.hetzner.cloud/v1/servers responseJSONPath : '{.servers[0].public_net.ipv4.ip}' requestHeadersSecretRef : name : hetzner-bearer-token namespace : default interval : 5m Self-Healing \u00b6 The IP controller reconciles itself at the given interval if an error occurs. See the following table: Error Interval None of the provided .spec.ipSources[*].urls return a valid IPv4 address 60s Fetching DNSRecord objects 30s Ingress \u00b6 cloudflare-operator creates a DNSRecord for each host specified in an Ingress object. You must set either the annotation cf.containeroo.ch/content or cf.containeroo.ch/ip-ref . To skip the creation of a DNSRecord , add the annotation cf.containeroo.ch/ignore=true . The following annotations are supported: Annotation Value Description cf.containeroo.ch/content IPv4 address or domain IPv4 address or domain to set as Cloudflare DNS record content cf.containeroo.ch/ttl 1 or 60 - 86400 Time to live, in seconds, of the Cloudflare DNS record. Must be between 60 and 86400, or 1 for 'automatic' cf.containeroo.ch/type A or CNAME Cloudflare DNS record type cf.containeroo.ch/interval 5m Interval at which cloudflare-operator will compare the Cloudflare DNS record with the DNSRecord object and reconcile the DNSRecord object cf.containeroo.ch/ignore true or false Skip creation of a DNS record cf.containeroo.ch/ignore If you add the label cf.containeroo.ch/ignore=true and cloudflare-operator has already created a DNSRecord , cloudflare-operator will clean up the DNSRecord (Kubernetes and Cloudflare). cf.containeroo.ch/interval This interval as two purposes: 1. It specifies at which interval cloudflare-operator will fetch the DNS record from Cloudflare and compare it with the DNSRecord object spec. If the DNS record does not match the spec, cloudflare-operator will update the DNS record on Cloudflare. 2. Interval at which cloudflare-operator will check if the corresponding DNSRecord object still exists. If it does not exist, cloudflare-operator will recreate the DNSRecord object. If not specified, cloudflare-operator will use a default interval of 5 minutes. Example: --- apiVersion : networking.k8s.io/v1 kind : Ingress metadata : annotations : cf.containeroo.ch/content : example.com name : blog namespace : blog spec : rules : - host : blog.example.com http : paths : - backend : service : name : blog port : name : http path : / pathType : Prefix apiVersion cloudflare-operator can only fetch ingresses with apiVersion networking.k8s.io/v1 . Older apiVersions like extensions/v1beta1 or networking.k8s.io/v1beta1 are not supported! self-healing \u00b6 The Ingress controller reconciles itself at the given interval if an error occurs. See the following table: Error Interval fetching DNSRecord objects 30s DNSRecord \u00b6 DNSRecords represent a Cloudflare DNS record within Kubernetes. interval specifies, at which interval cloudflare-operator will fetch the DNS record from Cloudflare and compare it with DNSRecord object spec ( proxied , ttl , type , content ). If the Cloudflare DNS record does not match the DNSRecord , the DNS record will be updated on Cloudflare. Default interval is set to 5 minutes. Therefore, the Kubernetes API can be looked at as a single source of truth. If a DNSRecord is deleted, cloudflare-operator will also delete the corresponding Cloudflare DNS record. Example: --- apiVersion : cf.containeroo.ch/v1beta1 kind : DNSRecord metadata : name : www-example-com namespace : www spec : name : www.example.com content : example.com type : CNAME proxied : true ttl : 1 interval : 5m Set spec.ipRef to the name of an IP object to automatically update the content with the address ( spec.address ) of the linked IP object. Example: --- apiVersion : cf.containeroo.ch/v1beta1 kind : DNSRecord metadata : name : blog-example-com namespace : blog spec : name : blog.example.com type : A ipRef : name : static-address proxied : true ttl : 1 interval : 5m self-healing \u00b6 The DNSRecord controller reconciles itself at the given interval if an error occurs. See the following table: Error Interval apiKey in secret from Account.spec.secretRef is empty 5s Fetching zones from Cloudflare 30s Zone.name in Cloudflare not found 30s Zone object not ready 5s Fetching zones from Cloudflare 30s Fetching DNS records from Cloudflare 30s Referenced IP object ( spec.ipRef.name ) not found 30s","title":"Core Concept"},{"location":"core_concept/#core-concept","text":"The goal of cloudflare-operator is to manage Cloudflare DNS records using Kubernetes objects.","title":"Core Concept"},{"location":"core_concept/#architecture","text":"","title":"Architecture"},{"location":"core_concept/#preamble-cloudflare-dns-record","text":"A Cloudflare DNS record has the following fields:","title":"Preamble Cloudflare DNS Record"},{"location":"core_concept/#type","text":"Cloudflare can handle multiple types. At the moment cloudflare-operator only supports A and CNAME records. A An A record must point to a valid IPv4 address (e.g. 172.4.20.69 ). cloudflare-operator use case Let cloudflare-operator create an A record for your root domain (e.g. example.com ). CNAME A CNAME record must point to a valid domain (e.g. example.com ). Cloudflare has the ability to point a CNAME record to an A record. Proxy Status and TTL of the CNAME record will be passed to the A record. cloudflare-operator use case Let cloudflare-operator create CNAME records for all your subdomains that point to your A record root domain. This is not mandatory but recommended, since cloudflare-operator only has to change one DNS record if your external IPv4 address changes.","title":"Type"},{"location":"core_concept/#name","text":"Must be a valid domain or subdomain (e.g. example.com or blog.example.com ).","title":"Name"},{"location":"core_concept/#content","text":"If type is A , the content must be a valid IPv4 address. If type is CNAME , the content must be a valid domain. cloudflare-operator use case Our recommendation is to point all your subdomains to your root domain (e.g. example.com ).","title":"Content"},{"location":"core_concept/#proxy-status","text":"Since Cloudflare is not only a DNS provider, it also has the ability to proxy requests through its CDN. This feature also enables WAF (web application firewall) protection. The proxied field is used to enable or disable this feature.","title":"Proxy Status"},{"location":"core_concept/#ttl","text":"TTL (time to live) is a setting that tells the DNS resolver how long to cache a query before requesting a new one.","title":"TTL"},{"location":"core_concept/#example","text":"Type Name Content Proxy Status TTL A example.com 178.4.20.69 true Auto CNAME www example.com true Auto A blog 142.251.36.35 true Auto CNAME vpn example.com false 120 www.example.com is hosted on your server at home with your external IPv4 address 178.4.20.69 . blog.example.com is hosted on a cloud provider instance with the IPv4 address 142.251.36.35","title":"Example"},{"location":"core_concept/#account","text":"The Account object contains your Cloudflare credentials (email & global API key) and owns Zone objects. Example: --- apiVersion : cf.containeroo.ch/v1beta1 kind : Account metadata : name : account-sample spec : email : mail@example.com globalAPIKey : secretRef : name : global-api-key namespace : default # managedZones: # - example.com # - other.com If cloudflare-operator should only manage some zones, you can specify them in the managedZones field.","title":"Account"},{"location":"core_concept/#self-healing","text":"The Account controller reconciles itself at the given interval if an error occurs. See the following table: Error Interval referenced secret ( secretRef ) not found 30s apiKey in referenced secret ( secretRef ) not found 30s connection to Cloudflare 30s fetching zones from Cloudflare 30s fetching zones from Zone object 30s","title":"Self-Healing"},{"location":"core_concept/#zone","text":"The Zone object stores the zone id. This object will be automatically created by cloudflare-operator based on the zones available in the Cloudflare account. If a zone is not in the Account.spec.managedZones field, it will not be managed by cloudflare-operator. cloudflare-operator checks if a given DNSRecord.spec.name ends with Zone.spec.name to evaluate in which Cloudflare zone the dns record should be created. cloudflare-operator will fetch in the given interval ( spec.interval ) all Cloudflare DNS records for each Zone object and deletes them on Cloudflare if they are not present in Kubernetes. The interval will be inherited from Account.spec.interval . Example: --- apiVersion : cf.containeroo.ch/v1beta1 kind : Zone metadata : name : example-com spec : id : abcdef123456 name : example.com","title":"Zone"},{"location":"core_concept/#self-healing_1","text":"The Zone controller reconcile itself at the given interval if an error occurs. See following table: Error Interval apiKey in secret from Account.secretRef is empty 5s fetching zones from Cloudflare 30s fetching DNSRecord objects 30s fetching DNS records from Cloudflare 30s","title":"Self-Healing"},{"location":"core_concept/#ip","text":"The IP object has two purposes: DRY (Don't Repeat Yourself) Let's say you have multiple DNSRecords pointing to the same IP. You can use the IP object to avoid repeating the IP address in the DNSRecord.spec.content field. If you change the IP object, cloudflare-operator will automatically update the DNSRecord.spec.content fields. Dynamic DNS If type is set to dynamic , cloudflare-operator will fetch your IPv4 address at the specified interval ( spec.interval ).","title":"IP"},{"location":"core_concept/#type-static","text":"An IP object with type static will update Cloudflare DNS records at the given interval ( DNSRecord.spec.interval ) with its address . Example: --- apiVersion : cf.containeroo.ch/v1beta1 kind : IP metadata : name : static-address spec : type : static address : 142.251.36.35","title":"Type Static"},{"location":"core_concept/#type-dynamic","text":"An IP object with type dynamic will fetch an IPv4 address from the defined .spec.ipSources[*].url at the given interval ( .spec.interval ). If more than one ipSources are configured, cloudflare-operator shuffles the list with ipSources and tries to fetch a valid IPv4 address, until the response is valid. If none of the ipSources returns a valid IPv4 address, cloudflare-operator will set the status of the IP object to failed . Default interval is set to 5 minutes. An ipSource can have the following keys: Key Description Example url URL to fetch IPv4 address https://ipecho.net requestBody Additional request body to send to the url requestHeaders Additional request headers to send to the url . The key will be passed as http header and the value will be passed as headers value Accept: application/json requestHeadersSecretRef Link to a secret with additional http headers. All secret keys will be passed as http header and the corresponding secret values will be passed as headers value See example below requestMethod HTTP request method. Possible values are GET , POST , PUT or DELETE GET responseRegex If the IPv4 address must be extracted from the http response. Uses the default golang regex engine. \\d{1,3}\\.\\d{1,3}.\\.\\d{1,3}\\.\\d{1,3} responseJSONPath JSONPath to extract IPv4 address. Uses the kubectl jsonpath library. '{.ip}' responseRegex Be aware that the http request will fetch the complete html document and not what you see in your browser! Note If neither responseJSONPath nor responseRegex is set, cloudflare-operator will try to parse the complete html document as an IPv4 address. Examples: Fetch your external IPv4 address from three \"IP\" providers --- apiVersion : cf.containeroo.ch/v1beta1 kind : IP metadata : name : external-ipv4 spec : type : dynamic ipSources : - url : https://ipecho.net responseRegex : \\d{1,3}\\.\\d{1,3}.\\.\\d{1,3}\\.\\d{1,3} - url : https://api.ipify.org?format=json responseJSONPath : '{.ip}' - url : https://checkip.amazonaws.com interval : 5m Info Because more than one ipSource is set, cloudflare-operator shuffles the list with ipSources and tries to fetch a valid IPv4 address, until the response is valid. If none of the ipSources returns a valid IPv4 address, cloudflare-operator will set the status of the IP object to failed . Fetch your external IPv4 from a cloud provider Create a secret with your provider API credentials: --- apiVersion : v1 kind : Secret metadata : name : hetzner-bearer-token namespace : default type : Opaque stringData : Authorization : Bearer TOKEN123 Create an IP object which references the secret created above. --- apiVersion : cf.containeroo.ch/v1beta1 kind : IP metadata : name : hetzner-ipv4 spec : type : dynamic ipSources : - url : https://api.hetzner.cloud/v1/servers responseJSONPath : '{.servers[0].public_net.ipv4.ip}' requestHeadersSecretRef : name : hetzner-bearer-token namespace : default interval : 5m","title":"Type Dynamic"},{"location":"core_concept/#self-healing_2","text":"The IP controller reconciles itself at the given interval if an error occurs. See the following table: Error Interval None of the provided .spec.ipSources[*].urls return a valid IPv4 address 60s Fetching DNSRecord objects 30s","title":"Self-Healing"},{"location":"core_concept/#ingress","text":"cloudflare-operator creates a DNSRecord for each host specified in an Ingress object. You must set either the annotation cf.containeroo.ch/content or cf.containeroo.ch/ip-ref . To skip the creation of a DNSRecord , add the annotation cf.containeroo.ch/ignore=true . The following annotations are supported: Annotation Value Description cf.containeroo.ch/content IPv4 address or domain IPv4 address or domain to set as Cloudflare DNS record content cf.containeroo.ch/ttl 1 or 60 - 86400 Time to live, in seconds, of the Cloudflare DNS record. Must be between 60 and 86400, or 1 for 'automatic' cf.containeroo.ch/type A or CNAME Cloudflare DNS record type cf.containeroo.ch/interval 5m Interval at which cloudflare-operator will compare the Cloudflare DNS record with the DNSRecord object and reconcile the DNSRecord object cf.containeroo.ch/ignore true or false Skip creation of a DNS record cf.containeroo.ch/ignore If you add the label cf.containeroo.ch/ignore=true and cloudflare-operator has already created a DNSRecord , cloudflare-operator will clean up the DNSRecord (Kubernetes and Cloudflare). cf.containeroo.ch/interval This interval as two purposes: 1. It specifies at which interval cloudflare-operator will fetch the DNS record from Cloudflare and compare it with the DNSRecord object spec. If the DNS record does not match the spec, cloudflare-operator will update the DNS record on Cloudflare. 2. Interval at which cloudflare-operator will check if the corresponding DNSRecord object still exists. If it does not exist, cloudflare-operator will recreate the DNSRecord object. If not specified, cloudflare-operator will use a default interval of 5 minutes. Example: --- apiVersion : networking.k8s.io/v1 kind : Ingress metadata : annotations : cf.containeroo.ch/content : example.com name : blog namespace : blog spec : rules : - host : blog.example.com http : paths : - backend : service : name : blog port : name : http path : / pathType : Prefix apiVersion cloudflare-operator can only fetch ingresses with apiVersion networking.k8s.io/v1 . Older apiVersions like extensions/v1beta1 or networking.k8s.io/v1beta1 are not supported!","title":"Ingress"},{"location":"core_concept/#self-healing_3","text":"The Ingress controller reconciles itself at the given interval if an error occurs. See the following table: Error Interval fetching DNSRecord objects 30s","title":"self-healing"},{"location":"core_concept/#dnsrecord","text":"DNSRecords represent a Cloudflare DNS record within Kubernetes. interval specifies, at which interval cloudflare-operator will fetch the DNS record from Cloudflare and compare it with DNSRecord object spec ( proxied , ttl , type , content ). If the Cloudflare DNS record does not match the DNSRecord , the DNS record will be updated on Cloudflare. Default interval is set to 5 minutes. Therefore, the Kubernetes API can be looked at as a single source of truth. If a DNSRecord is deleted, cloudflare-operator will also delete the corresponding Cloudflare DNS record. Example: --- apiVersion : cf.containeroo.ch/v1beta1 kind : DNSRecord metadata : name : www-example-com namespace : www spec : name : www.example.com content : example.com type : CNAME proxied : true ttl : 1 interval : 5m Set spec.ipRef to the name of an IP object to automatically update the content with the address ( spec.address ) of the linked IP object. Example: --- apiVersion : cf.containeroo.ch/v1beta1 kind : DNSRecord metadata : name : blog-example-com namespace : blog spec : name : blog.example.com type : A ipRef : name : static-address proxied : true ttl : 1 interval : 5m","title":"DNSRecord"},{"location":"core_concept/#self-healing_4","text":"The DNSRecord controller reconciles itself at the given interval if an error occurs. See the following table: Error Interval apiKey in secret from Account.spec.secretRef is empty 5s Fetching zones from Cloudflare 30s Zone.name in Cloudflare not found 30s Zone object not ready 5s Fetching zones from Cloudflare 30s Fetching DNS records from Cloudflare 30s Referenced IP object ( spec.ipRef.name ) not found 30s","title":"self-healing"},{"location":"getting_started/","text":"Getting Started \u00b6 This tutorial shows you how to start using cloudflare-operator. Preparation \u00b6 Create a secret with your Cloudflare global API Key. The key containing the API key must be named apiKey . kubectl apply -f - << EOF apiVersion: v1 kind: Secret type: Opaque metadata: name: cloudflare-global-api-key namespace: cloudflare-operator stringData: apiKey: 1234 EOF Create an Account object: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: Account metadata: name: account-sample spec: email: mail@example.com globalAPIKey: secretRef: name: cloudflare-global-api-key namespace: cloudflare-operator EOF Create an IP object for your root domain to automatically update your external IPv4 address: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: IP metadata: name: dynamic-external-ipv4-address spec: type: dynamic interval: 5m ipSources: - url: https://ifconfig.me/ip - url: https://ipecho.net/plain - url: https://myip.is/ip/ - url: https://checkip.amazonaws.com - url: https://api.ipify.org EOF Create a DNSRecord with type A for your root domain: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: DNSRecord metadata: name: root-domain namespace: cloudflare-operator spec: name: example.com type: A ipRef: name: dynamic-external-ipv4-address proxied: true ttl: 1 interval: 5m EOF Annotate all ingresses with your root domain, so cloudflare-operator can create DNSRecords for all hosts specified in all ingresses: kubectl annotate ingress \\ --all-namespaces \\ --all \\ \"cf.containeroo.ch/content=example.com\" Info If you do not want to expose some ingresses, delete the annotation kubectl annotate ingress --namespace <NAMESPACE> <INGRESS-NAME> cf.containeroo.ch/content- and add the annotation kubectl annotate ingress --namespace <NAMESPACE> <INGRESS-NAME> cf.containeroo.ch/ignore=true to skip the creation of the DNSRecord . Additional DNSRecord \u00b6 VPN \u00b6 Let's say you have a vpn-server on a Raspberry Pi. In order to manage the Cloudflare DNS record for you, create a DNSRecord object: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: DNSRecord metadata: name: vpn namespace: cloudflare-operator spec: name: vpn.example.com type: A ipRef: name: dynamic-external-ipv4-address proxied: false ttl: 120 interval: 5m EOF Because you linked the DNSRecord to your IP object ( spec.ipRef.name ), cloudflare-operator will also update the content of the Cloudflare DNS record for you, if your external IPv4 address changes. Set the ttl to 120 to shorten waiting time if your external IPv4 address has changed. Set proxied to false because Cloudflare cannot proxy vpn traffic. External Service \u00b6 Let's say you have an external website blog.example.com hosted on a cloud VPC and your external cloud instance IP address is 178.4.20.69 . kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: DNSRecord metadata: name: blog namespace: cloudflare-operator spec: name: blob.example.com content: 178.4.20.69 type: A proxied: true ttl: 1 interval: 5m EOF Now your blog will be routed through Cloudflare. Note Do not forget to change the content of the DNSRecord if the external IPv4 address of your cloud instance has changed! Bonus tip If you have multiple cloud services accessible with the same IP, you can also create an IP object and link this with ipRef.name , so you only have to change the IP address of your cloud instance once in the IP object. If your cloud provider has an API returning the public IPv4 address of your instance, you can also create an IP object with type dynamic and reference it in the DNSRecord . Create a secret with your provider API credentials: kubectl apply -f - << EOF apiVersion: v1 kind: Secret metadata: name: hetzner-bearer-token namespace: default type: Opaque stringData: Authorization: Bearer TOKEN123 EOF Create an IP object with a reference to the secret created above: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: IP metadata: name: hetzner-ipv4 spec: type: dynamic ipSources: - url: https://api.hetzner.cloud/v1/servers responseJSONPath: '{.servers[0].public_net.ipv4.ip}' requestHeadersSecretRef: name: hetzner-bearer-token namespace: default interval: 5m EOF Create a DNSRecord with a reference to the IP object created above: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: DNSRecord metadata: name: blog namespace: cloudflare-operator spec: name: blob.example.com ipRef: name: hetzner-ipv4 type: A proxied: true ttl: 1 interval: 5m EOF","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"This tutorial shows you how to start using cloudflare-operator.","title":"Getting Started"},{"location":"getting_started/#preparation","text":"Create a secret with your Cloudflare global API Key. The key containing the API key must be named apiKey . kubectl apply -f - << EOF apiVersion: v1 kind: Secret type: Opaque metadata: name: cloudflare-global-api-key namespace: cloudflare-operator stringData: apiKey: 1234 EOF Create an Account object: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: Account metadata: name: account-sample spec: email: mail@example.com globalAPIKey: secretRef: name: cloudflare-global-api-key namespace: cloudflare-operator EOF Create an IP object for your root domain to automatically update your external IPv4 address: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: IP metadata: name: dynamic-external-ipv4-address spec: type: dynamic interval: 5m ipSources: - url: https://ifconfig.me/ip - url: https://ipecho.net/plain - url: https://myip.is/ip/ - url: https://checkip.amazonaws.com - url: https://api.ipify.org EOF Create a DNSRecord with type A for your root domain: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: DNSRecord metadata: name: root-domain namespace: cloudflare-operator spec: name: example.com type: A ipRef: name: dynamic-external-ipv4-address proxied: true ttl: 1 interval: 5m EOF Annotate all ingresses with your root domain, so cloudflare-operator can create DNSRecords for all hosts specified in all ingresses: kubectl annotate ingress \\ --all-namespaces \\ --all \\ \"cf.containeroo.ch/content=example.com\" Info If you do not want to expose some ingresses, delete the annotation kubectl annotate ingress --namespace <NAMESPACE> <INGRESS-NAME> cf.containeroo.ch/content- and add the annotation kubectl annotate ingress --namespace <NAMESPACE> <INGRESS-NAME> cf.containeroo.ch/ignore=true to skip the creation of the DNSRecord .","title":"Preparation"},{"location":"getting_started/#additional-dnsrecord","text":"","title":"Additional DNSRecord"},{"location":"getting_started/#vpn","text":"Let's say you have a vpn-server on a Raspberry Pi. In order to manage the Cloudflare DNS record for you, create a DNSRecord object: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: DNSRecord metadata: name: vpn namespace: cloudflare-operator spec: name: vpn.example.com type: A ipRef: name: dynamic-external-ipv4-address proxied: false ttl: 120 interval: 5m EOF Because you linked the DNSRecord to your IP object ( spec.ipRef.name ), cloudflare-operator will also update the content of the Cloudflare DNS record for you, if your external IPv4 address changes. Set the ttl to 120 to shorten waiting time if your external IPv4 address has changed. Set proxied to false because Cloudflare cannot proxy vpn traffic.","title":"VPN"},{"location":"getting_started/#external-service","text":"Let's say you have an external website blog.example.com hosted on a cloud VPC and your external cloud instance IP address is 178.4.20.69 . kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: DNSRecord metadata: name: blog namespace: cloudflare-operator spec: name: blob.example.com content: 178.4.20.69 type: A proxied: true ttl: 1 interval: 5m EOF Now your blog will be routed through Cloudflare. Note Do not forget to change the content of the DNSRecord if the external IPv4 address of your cloud instance has changed! Bonus tip If you have multiple cloud services accessible with the same IP, you can also create an IP object and link this with ipRef.name , so you only have to change the IP address of your cloud instance once in the IP object. If your cloud provider has an API returning the public IPv4 address of your instance, you can also create an IP object with type dynamic and reference it in the DNSRecord . Create a secret with your provider API credentials: kubectl apply -f - << EOF apiVersion: v1 kind: Secret metadata: name: hetzner-bearer-token namespace: default type: Opaque stringData: Authorization: Bearer TOKEN123 EOF Create an IP object with a reference to the secret created above: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: IP metadata: name: hetzner-ipv4 spec: type: dynamic ipSources: - url: https://api.hetzner.cloud/v1/servers responseJSONPath: '{.servers[0].public_net.ipv4.ip}' requestHeadersSecretRef: name: hetzner-bearer-token namespace: default interval: 5m EOF Create a DNSRecord with a reference to the IP object created above: kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: DNSRecord metadata: name: blog namespace: cloudflare-operator spec: name: blob.example.com ipRef: name: hetzner-ipv4 type: A proxied: true ttl: 1 interval: 5m EOF","title":"External Service"},{"location":"installation/","text":"Installation \u00b6 Installing with Helm \u00b6 cloudflare-operator provides a Helm chart as a first-class method of installation on Kubernetes. Prerequisites \u00b6 Install Helm version 3 or later Install a supported version of Kubernetes Steps \u00b6 Add the containeroo Helm repository: This repository is the only supported source of containeroo charts. helm repo add containeroo https://charts.containeroo.ch Update your local Helm chart repository cache: helm repo update Install CustomResourceDefinitions cloudflare-operator requires a number of CRD resources, which must be installed manually using kubectl . Installing CRDs with kubectl: kubectl apply -f https://github.com/containeroo/cloudflare-operator/releases/download/v0.3.2/crds.yaml Install cloudflare-operator To install the cloudflare-operator Helm chart, use the Helm install command as described below. helm install \\ cloudflare-operator containeroo/cloudflare-operator \\ --namespace cloudflare-operator \\ --create-namespace \\ --version v0.3.2 A full list of available Helm values is on cloudflare-operator\u2019s ArtifactHub page . Output YAML \u00b6 Instead of directly installing cloudflare-operator using Helm, a static YAML manifest can be generated using the Helm template command. This static manifest can be tuned by providing the flags to overwrite the default Helm values: helm template \\ cloudflare-operator containeroo/cloudflare-operator \\ --namespace cloudflare-operator \\ --create-namespace \\ --version v0.3.2 \\ --set your.value = here Uninstalling \u00b6 Warning To uninstall cloudflare-operator you should always use the same process for installing but in reverse. Deviating from the following process whether cloudflare-operator has been installed from static manifests or Helm can cause issues and potentially broken states. Please ensure you follow the below steps when uninstalling to prevent this happening. Before continuing, ensure that all cloudflare-operator resources that have been created by users have been deleted. You can check for any existing resources with the following command: kubectl get Account,DNSRecord,IP --all-namespaces Once all these resources have been deleted you are ready to uninstall cloudflare-operator using the procedure determined by how you installed. Uninstalling with Helm \u00b6 Uninstalling cloudflare-operator from a helm installation is a case of running the installation process, in reverse, using the delete command on both kubectl and helm . helm --namespace cloudflare-operator delete cloudflare-operator kubectl delete namespace cloudflare-operator Finally, delete the cloudflare-operator CustomResourceDefinitions using the link to the version vX.Y.Z you installed: Warning This command will also remove installed cloudflare-operator objects. All cloudflare-operator resources will be removed by Kubernetes' garbage collector. kubectl delete -f https://github.com/containeroo/cloudflare-operator/releases/download/v0.3.2/crds.yaml Namespace Stuck in Terminating State \u00b6 If the namespace has been marked for deletion without deleting the cloudflare-operator installation first, the namespace may become stuck in a terminating state. This is typically due to the fact that the APIService resource still exists however the webhook is no longer running so is no longer reachable. To resolve this, ensure you have run the above commands correctly, and if you\u2019re still experiencing issues then run: kubectl delete apiservice v1beta1.cf.containeroo.ch","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#installing-with-helm","text":"cloudflare-operator provides a Helm chart as a first-class method of installation on Kubernetes.","title":"Installing with Helm"},{"location":"installation/#prerequisites","text":"Install Helm version 3 or later Install a supported version of Kubernetes","title":"Prerequisites"},{"location":"installation/#steps","text":"Add the containeroo Helm repository: This repository is the only supported source of containeroo charts. helm repo add containeroo https://charts.containeroo.ch Update your local Helm chart repository cache: helm repo update Install CustomResourceDefinitions cloudflare-operator requires a number of CRD resources, which must be installed manually using kubectl . Installing CRDs with kubectl: kubectl apply -f https://github.com/containeroo/cloudflare-operator/releases/download/v0.3.2/crds.yaml Install cloudflare-operator To install the cloudflare-operator Helm chart, use the Helm install command as described below. helm install \\ cloudflare-operator containeroo/cloudflare-operator \\ --namespace cloudflare-operator \\ --create-namespace \\ --version v0.3.2 A full list of available Helm values is on cloudflare-operator\u2019s ArtifactHub page .","title":"Steps"},{"location":"installation/#output-yaml","text":"Instead of directly installing cloudflare-operator using Helm, a static YAML manifest can be generated using the Helm template command. This static manifest can be tuned by providing the flags to overwrite the default Helm values: helm template \\ cloudflare-operator containeroo/cloudflare-operator \\ --namespace cloudflare-operator \\ --create-namespace \\ --version v0.3.2 \\ --set your.value = here","title":"Output YAML"},{"location":"installation/#uninstalling","text":"Warning To uninstall cloudflare-operator you should always use the same process for installing but in reverse. Deviating from the following process whether cloudflare-operator has been installed from static manifests or Helm can cause issues and potentially broken states. Please ensure you follow the below steps when uninstalling to prevent this happening. Before continuing, ensure that all cloudflare-operator resources that have been created by users have been deleted. You can check for any existing resources with the following command: kubectl get Account,DNSRecord,IP --all-namespaces Once all these resources have been deleted you are ready to uninstall cloudflare-operator using the procedure determined by how you installed.","title":"Uninstalling"},{"location":"installation/#uninstalling-with-helm","text":"Uninstalling cloudflare-operator from a helm installation is a case of running the installation process, in reverse, using the delete command on both kubectl and helm . helm --namespace cloudflare-operator delete cloudflare-operator kubectl delete namespace cloudflare-operator Finally, delete the cloudflare-operator CustomResourceDefinitions using the link to the version vX.Y.Z you installed: Warning This command will also remove installed cloudflare-operator objects. All cloudflare-operator resources will be removed by Kubernetes' garbage collector. kubectl delete -f https://github.com/containeroo/cloudflare-operator/releases/download/v0.3.2/crds.yaml","title":"Uninstalling with Helm"},{"location":"installation/#namespace-stuck-in-terminating-state","text":"If the namespace has been marked for deletion without deleting the cloudflare-operator installation first, the namespace may become stuck in a terminating state. This is typically due to the fact that the APIService resource still exists however the webhook is no longer running so is no longer reachable. To resolve this, ensure you have run the above commands correctly, and if you\u2019re still experiencing issues then run: kubectl delete apiservice v1beta1.cf.containeroo.ch","title":"Namespace Stuck in Terminating State"},{"location":"monitoring/","text":"Monitoring with Prometheus \u00b6 Prerequisites \u00b6 Prometheus - collects metrics from the cloudflare-operator controllers and Kubernetes API Grafana dashboards - displays cloudflare-operator stats kube-state-metrics - generates metrics about the state of the Kubernetes objects The easiest way to deploy all necessary components is to use kube-prometheus-stack . Install cloudflare-operator Grafana Dashboard \u00b6 Note that the cloudflare-operator exposes the /metrics endpoint on port 8080 . When using Prometheus Operator you need a PodMonitor object to configure scraping for the controller. Apply the config/manifests/prometheus/monitor.yaml containing the PodMonitor and create a ConfigMap with the cloudflare-operator dashboard: # Create a podmonitor kubectl apply -f https://raw.githubusercontent.com/containeroo/cloudflare-operator/master/config/manifests/prometheus/monitor.yaml # Download Grafana dashboard wget https://raw.githubusercontent.com/containeroo/cloudflare-operator/master/config/manifests/grafana/dashboards/overview.json -O /tmp/grafana-dashboard-cloudflare-operator.json # Create the configmap kubectl create configmap grafana-dashboard-cloudflare-operator --from-file = /tmp/grafana-dashboard-cloudflare-operator.json # Add label so Grafana can fetch dashboard kubectl label configmap grafana-dashboard-cloudflare-operator grafana_dashboard = \"1\" Metrics \u00b6 For each cf.containeroo.ch kind, the controller exposes a gauge metric to track the status condition. Ready status metrics: cloudflare_operator_account_status cloudflare_operator_dns_record_status cloudflare_operator_ip_status cloudflare_operator_zone_status Alertmanager example: groups : - alert : DNSRecordFailures annotations : summary : DNSRecord {{ $labels.name }} ({{ $labels.record_name }}) in namespace {{ $labels.exported_namespace }} failed expr : cloudflare_operator_dns_record_status > 0 for : 1m labels : severity : critical","title":"Monitoring"},{"location":"monitoring/#monitoring-with-prometheus","text":"","title":"Monitoring with Prometheus"},{"location":"monitoring/#prerequisites","text":"Prometheus - collects metrics from the cloudflare-operator controllers and Kubernetes API Grafana dashboards - displays cloudflare-operator stats kube-state-metrics - generates metrics about the state of the Kubernetes objects The easiest way to deploy all necessary components is to use kube-prometheus-stack .","title":"Prerequisites"},{"location":"monitoring/#install-cloudflare-operator-grafana-dashboard","text":"Note that the cloudflare-operator exposes the /metrics endpoint on port 8080 . When using Prometheus Operator you need a PodMonitor object to configure scraping for the controller. Apply the config/manifests/prometheus/monitor.yaml containing the PodMonitor and create a ConfigMap with the cloudflare-operator dashboard: # Create a podmonitor kubectl apply -f https://raw.githubusercontent.com/containeroo/cloudflare-operator/master/config/manifests/prometheus/monitor.yaml # Download Grafana dashboard wget https://raw.githubusercontent.com/containeroo/cloudflare-operator/master/config/manifests/grafana/dashboards/overview.json -O /tmp/grafana-dashboard-cloudflare-operator.json # Create the configmap kubectl create configmap grafana-dashboard-cloudflare-operator --from-file = /tmp/grafana-dashboard-cloudflare-operator.json # Add label so Grafana can fetch dashboard kubectl label configmap grafana-dashboard-cloudflare-operator grafana_dashboard = \"1\"","title":"Install cloudflare-operator Grafana Dashboard"},{"location":"monitoring/#metrics","text":"For each cf.containeroo.ch kind, the controller exposes a gauge metric to track the status condition. Ready status metrics: cloudflare_operator_account_status cloudflare_operator_dns_record_status cloudflare_operator_ip_status cloudflare_operator_zone_status Alertmanager example: groups : - alert : DNSRecordFailures annotations : summary : DNSRecord {{ $labels.name }} ({{ $labels.record_name }}) in namespace {{ $labels.exported_namespace }} failed expr : cloudflare_operator_dns_record_status > 0 for : 1m labels : severity : critical","title":"Metrics"},{"location":"operations/","text":"Operations \u00b6 Account \u00b6 To view all Account objects use the command: kubectl get accounts.cf.containeroo.ch Output: NAME EMAIL PHASE main admin@example.com Active Zone \u00b6 To view all Zone objects use the command: kubectl get zones.cf.containeroo.ch Output: NAME ZONE NAME ID PHASE example-com example.com 69 Active other-com other.com 420 Active IP \u00b6 To view all IP objects use the command: kubectl get ips.cf.containeroo.ch Output: NAME ADDRESS TYPE PHASE external-ipv4 178.4.20.69 dynamic Ready static-address 142.251.36.35 static Ready DNSRecord \u00b6 To view all DNSRecord objects use the command: kubectl get dnsrecords.cf.containeroo.ch --all-namespaces Output: NAMESPACE NAME RECORD NAME TYPE CONTENT PROXIED TTL STATUS blog blog-example-com blog.example.com A 142.251.36.35 true 1 Created www www-exmaple-com www.example.com CNAME example.com true 1 Created cloudflare-operator vpn-example-com vpn.example.com CNAME example.com false 120 Created cloudflare-operator example-com example.com A 178.4.20.69 true 1 Created Troubleshooting \u00b6 Usually, cloudflare-operator will store errors in the corresponding object in the status.message field and set the object phase ( stattus.phase ) to Failed . Example \u00b6 Create a new invalid DNSRecord : kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: DNSRecord metadata: name: www-example-com namespace: cloudflare-operator spec: name: www.example.com type: CNAME proxied: true ttl: 1 interval: 5m EOF Info The problem is, that type is set to CNAME , but no content is set. List DNSRecords : kubectl get dnsrecords --namespace cloudflare-operator www-example-com Output: NAME RECORD NAME TYPE CONTENT PROXIED TTL STATUS blog-example-com blog.example.com A 142.251.36.35 true 1 Created www-exmaple-com www.example.com CNAME true 1 Failed vpn-example-com vpn.example.com CNAME example.com false 120 Created example-com example.com A 178.4.20.69 true 1 Created As you can see, the status is Failed . Output the newly created DNSRecord to console as YAML: kubectl get dnsrecords --namespace cloudflare-operator www-example-com -oyaml Output: apiVersion : cf.containeroo.ch/v1beta1 kind : DNSRecord metadata : ... name : www-example-com namespace : cloudflare-operator ... spec : interval : 5m name : www.example.com proxied : true ttl : 1 type : CNAME status : message : DNSRecord content is empty. Either content or ipRef must be set phase : Failed recordID : \"\" In the status.message you can see the error. The Phase is also set to Failed . Remove Finalizers From All DNSRecords \u00b6 If you want to remove all finalizers from all DNSRecords at once, you can issue the following command: kubectl get dnsrecords \\ --all-namespaces \\ --no-headers \\ --output = custom-columns = 'namespace:.metadata.namespace,name:.metadata.name' | \\ xargs -n 2 \\ kubectl patch dnsrecords.cf.containeroo.ch \\ --patch '{\"metadata\":{\"finalizers\":null}}' \\ --type merge \\ --namespace Metrics \u00b6 When installing cloudflare-operator with helm, set the following values to enable metrics and Prometheus rules: metrics : podMonitor : enabled : true prometheusRule : enabled : true cloudflare-operator then exposes the following metrics: cloudflare_operator_account_status cloudflare_operator_dns_record_status cloudflare_operator_ip_status cloudflare_operator_zone_status There is also a Grafana dashboard. You can learn more here .","title":"Operations"},{"location":"operations/#operations","text":"","title":"Operations"},{"location":"operations/#account","text":"To view all Account objects use the command: kubectl get accounts.cf.containeroo.ch Output: NAME EMAIL PHASE main admin@example.com Active","title":"Account"},{"location":"operations/#zone","text":"To view all Zone objects use the command: kubectl get zones.cf.containeroo.ch Output: NAME ZONE NAME ID PHASE example-com example.com 69 Active other-com other.com 420 Active","title":"Zone"},{"location":"operations/#ip","text":"To view all IP objects use the command: kubectl get ips.cf.containeroo.ch Output: NAME ADDRESS TYPE PHASE external-ipv4 178.4.20.69 dynamic Ready static-address 142.251.36.35 static Ready","title":"IP"},{"location":"operations/#dnsrecord","text":"To view all DNSRecord objects use the command: kubectl get dnsrecords.cf.containeroo.ch --all-namespaces Output: NAMESPACE NAME RECORD NAME TYPE CONTENT PROXIED TTL STATUS blog blog-example-com blog.example.com A 142.251.36.35 true 1 Created www www-exmaple-com www.example.com CNAME example.com true 1 Created cloudflare-operator vpn-example-com vpn.example.com CNAME example.com false 120 Created cloudflare-operator example-com example.com A 178.4.20.69 true 1 Created","title":"DNSRecord"},{"location":"operations/#troubleshooting","text":"Usually, cloudflare-operator will store errors in the corresponding object in the status.message field and set the object phase ( stattus.phase ) to Failed .","title":"Troubleshooting"},{"location":"operations/#example","text":"Create a new invalid DNSRecord : kubectl apply -f - << EOF apiVersion: cf.containeroo.ch/v1beta1 kind: DNSRecord metadata: name: www-example-com namespace: cloudflare-operator spec: name: www.example.com type: CNAME proxied: true ttl: 1 interval: 5m EOF Info The problem is, that type is set to CNAME , but no content is set. List DNSRecords : kubectl get dnsrecords --namespace cloudflare-operator www-example-com Output: NAME RECORD NAME TYPE CONTENT PROXIED TTL STATUS blog-example-com blog.example.com A 142.251.36.35 true 1 Created www-exmaple-com www.example.com CNAME true 1 Failed vpn-example-com vpn.example.com CNAME example.com false 120 Created example-com example.com A 178.4.20.69 true 1 Created As you can see, the status is Failed . Output the newly created DNSRecord to console as YAML: kubectl get dnsrecords --namespace cloudflare-operator www-example-com -oyaml Output: apiVersion : cf.containeroo.ch/v1beta1 kind : DNSRecord metadata : ... name : www-example-com namespace : cloudflare-operator ... spec : interval : 5m name : www.example.com proxied : true ttl : 1 type : CNAME status : message : DNSRecord content is empty. Either content or ipRef must be set phase : Failed recordID : \"\" In the status.message you can see the error. The Phase is also set to Failed .","title":"Example"},{"location":"operations/#remove-finalizers-from-all-dnsrecords","text":"If you want to remove all finalizers from all DNSRecords at once, you can issue the following command: kubectl get dnsrecords \\ --all-namespaces \\ --no-headers \\ --output = custom-columns = 'namespace:.metadata.namespace,name:.metadata.name' | \\ xargs -n 2 \\ kubectl patch dnsrecords.cf.containeroo.ch \\ --patch '{\"metadata\":{\"finalizers\":null}}' \\ --type merge \\ --namespace","title":"Remove Finalizers From All DNSRecords"},{"location":"operations/#metrics","text":"When installing cloudflare-operator with helm, set the following values to enable metrics and Prometheus rules: metrics : podMonitor : enabled : true prometheusRule : enabled : true cloudflare-operator then exposes the following metrics: cloudflare_operator_account_status cloudflare_operator_dns_record_status cloudflare_operator_ip_status cloudflare_operator_zone_status There is also a Grafana dashboard. You can learn more here .","title":"Metrics"},{"location":"roadmap/","text":"Roadmap \u00b6 These features are in planning: Send Slack notifications for certain events Add support for IPv6 addresses","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"These features are in planning: Send Slack notifications for certain events Add support for IPv6 addresses","title":"Roadmap"},{"location":"upgrade_notes/","text":"Upgrade Notes \u00b6 From v0.1.3 to v0.2.0 \u00b6 Properties of the cloudflare-operator CRD ips.cf.containeroo.ch has BREAKING changes. You have to delete all IP objects before updating and re-create them according to the new specification: kubectl delete ip --all New ips.cf.containeroo.ch CRD specification can be found here . If you created an IP object to sync your external IPv4 address and did not set dynamicIPSources , you have to delete that object and create a new IP object. Example: kubectl apply -f - << EOF --- apiVersion: cf.containeroo.ch/v1beta1 kind: IP metadata: name: dynamic-external-ipv4-address spec: type: dynamic interval: 5m ipSources: - url: https://ifconfig.me/ip - url: https://ipecho.net/plain - url: https://myip.is/ip/ - url: https://checkip.amazonaws.com - url: https://api.ipify.org EOF From v0.0.x to v0.1.0 \u00b6 The apiVersion of the cloudflare-operator CRDs changed from cf.containeroo.ch/v1alpha1 to cf.containeroo.ch/v1beta1 . Please update your CRDs to cf.containeroo.ch/v1beta1 before upgrading to v0.1.0 : kubectl apply --server-side -f https://github.com/containeroo/cloudflare-operator/releases/download/v0.1.0/crds.yaml","title":"Upgrade Notes"},{"location":"upgrade_notes/#upgrade-notes","text":"","title":"Upgrade Notes"},{"location":"upgrade_notes/#from-v013-to-v020","text":"Properties of the cloudflare-operator CRD ips.cf.containeroo.ch has BREAKING changes. You have to delete all IP objects before updating and re-create them according to the new specification: kubectl delete ip --all New ips.cf.containeroo.ch CRD specification can be found here . If you created an IP object to sync your external IPv4 address and did not set dynamicIPSources , you have to delete that object and create a new IP object. Example: kubectl apply -f - << EOF --- apiVersion: cf.containeroo.ch/v1beta1 kind: IP metadata: name: dynamic-external-ipv4-address spec: type: dynamic interval: 5m ipSources: - url: https://ifconfig.me/ip - url: https://ipecho.net/plain - url: https://myip.is/ip/ - url: https://checkip.amazonaws.com - url: https://api.ipify.org EOF","title":"From v0.1.3 to v0.2.0"},{"location":"upgrade_notes/#from-v00x-to-v010","text":"The apiVersion of the cloudflare-operator CRDs changed from cf.containeroo.ch/v1alpha1 to cf.containeroo.ch/v1beta1 . Please update your CRDs to cf.containeroo.ch/v1beta1 before upgrading to v0.1.0 : kubectl apply --server-side -f https://github.com/containeroo/cloudflare-operator/releases/download/v0.1.0/crds.yaml","title":"From v0.0.x to v0.1.0"}]}